// Copyright 2019 - 2022 The Samply Community
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fhir

import (
	"encoding/json"
	"fmt"
	"strings"
)

// THIS FILE IS GENERATED BY https://github.com/samply/golang-fhir-models
// PLEASE DO NOT EDIT BY HAND

// DiscriminatorType is documented here http://hl7.org/fhir/ValueSet/discriminator-type
type DiscriminatorType int

const (
	DiscriminatorTypeValue DiscriminatorType = iota
	DiscriminatorTypeExists
	DiscriminatorTypePattern
	DiscriminatorTypeType
	DiscriminatorTypeProfile
	DiscriminatorTypePosition
)

func (code DiscriminatorType) MarshalJSON() ([]byte, error) {
	return json.Marshal(code.Code())
}
func (code *DiscriminatorType) UnmarshalJSON(json []byte) error {
	s := strings.Trim(string(json), "\"")
	switch s {
	case "value":
		*code = DiscriminatorTypeValue
	case "exists":
		*code = DiscriminatorTypeExists
	case "pattern":
		*code = DiscriminatorTypePattern
	case "type":
		*code = DiscriminatorTypeType
	case "profile":
		*code = DiscriminatorTypeProfile
	case "position":
		*code = DiscriminatorTypePosition
	default:
		return fmt.Errorf("unknown DiscriminatorType code `%s`", s)
	}
	return nil
}
func (code DiscriminatorType) String() string {
	return code.Code()
}
func (code DiscriminatorType) Code() string {
	switch code {
	case DiscriminatorTypeValue:
		return "value"
	case DiscriminatorTypeExists:
		return "exists"
	case DiscriminatorTypePattern:
		return "pattern"
	case DiscriminatorTypeType:
		return "type"
	case DiscriminatorTypeProfile:
		return "profile"
	case DiscriminatorTypePosition:
		return "position"
	}
	return "<unknown>"
}
func (code DiscriminatorType) Display() string {
	switch code {
	case DiscriminatorTypeValue:
		return "Value"
	case DiscriminatorTypeExists:
		return "Exists"
	case DiscriminatorTypePattern:
		return "Pattern"
	case DiscriminatorTypeType:
		return "Type"
	case DiscriminatorTypeProfile:
		return "Profile"
	case DiscriminatorTypePosition:
		return "Position"
	}
	return "<unknown>"
}
func (code DiscriminatorType) Definition() string {
	switch code {
	case DiscriminatorTypeValue:
		return "The slices have different values in the nominated element, as determined by the applicable fixed value, pattern, or required ValueSet binding."
	case DiscriminatorTypeExists:
		return "The slices are differentiated by the presence or absence of the nominated element. There SHALL be no more than two slices. The slices are differentiated by the fact that one must have a max of 0 and the other must have a min of 1 (or more).  The order in which the slices are declared doesn't matter."
	case DiscriminatorTypePattern:
		return "The slices have different values in the nominated element, as determined by the applicable fixed value, pattern, or required ValueSet binding. This has the same meaning as 'value' and is deprecated."
	case DiscriminatorTypeType:
		return "The slices are differentiated by type of the nominated element."
	case DiscriminatorTypeProfile:
		return "The slices are differentiated by conformance of the nominated element to a specified profile. Note that if the path specifies .resolve() then the profile is the target profile on the reference. In this case, validation by the possible profiles is required to differentiate the slices."
	case DiscriminatorTypePosition:
		return "The slices are differentiated by their index. This is only possible if all but the last slice have min=max cardinality, and the (optional) last slice contains other undifferentiated elements."
	}
	return "<unknown>"
}
